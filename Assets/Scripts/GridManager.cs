using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using InputManagement;
using Levels;
using Nodes;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;

public class GridManager : MonoBehaviour
{
    public const int GRID_SIZE_X = 4;
    public const int GRID_SIZE_Y = 4;
    public const float NODE_HEIGHT = 0.09f;
    
    public LevelGenerator generator;
    public CameraMovement cameraMovement;
    
    private const float NodeSizeX = 1f;
    private const float NodeSizeY = 1f;
    
    private NodeContext _lastSelectedNode;
    private bool _gameIsOver = false;
    private bool _blockInputsWhileTween = false;

    private List<NodeContext> _grid;

    public static Action OnWin;
    public static Action OnLose;

    public UnityEvent onSwipeSuccessful;

    private void Start()
    {
        InputManager.OnSwipeDetected += OnSwipe;
        LevelManager.Instance.OnSandwichDone += CheckSandwichStack;
        LevelManager.Instance.OnNewLevelStart += ClearAndInstantiateGrid;
    }
    
    public void InstantiateGrid()
    {
        var rows = GRID_SIZE_X;
        var columns = GRID_SIZE_Y;

        _grid = new List<NodeContext>();

        var levelData = LevelManager.Instance.GetCurrentLevelData();

        if (levelData.autoGenerated) 
        {
            levelData = generator.GenerateLevel(levelData);
        }

        for (var x = 0; x < rows; x++)
        {
            for (var y = 0; y < columns; y++)
            {
                var nodePosition = new Vector2(x, y);
                var nodeContent = GetNodeContent(levelData, nodePosition);
                InstantiateNode(nodeContent, nodePosition);
            }
        }
            
        AssignSurroundingsToContext();
    }

    private NodeContent GetNodeContent(Level actualLevel, Vector2 position)
    {
        return actualLevel.nodes.Exists(node => node.position == position) 
            ? actualLevel.nodes.FirstOrDefault(n => n.position == position).content
            : NodeContent.Empty;
    }

    private void InstantiateNode(NodeContent content, Vector2 position)
    {
        var nodeIngredient = ObjectHandler.Instance.GetObjectFromContent(content);
        var node = Instantiate(nodeIngredient, CalculateNodePosition(position), Quaternion.identity, transform);

        var context = node.GetComponent<NodeContext>();
        context.content = content;
        context.assignedNodeObject = node;
        context.position = position;

        context.Interactable = content != NodeContent.Empty;
        
        _grid.Add(context);
    }

    private Vector3 CalculateNodePosition(Vector2 gridPosition)
    {
        return new Vector3(NodeSizeX * gridPosition.x, 0, NodeSizeY * gridPosition.y);
    }

    private void AssignSurroundingsToContext()
    {
        foreach (var nodeContext in _grid)
        {
            var nodePosition = nodeContext.position;
            nodeContext.surroundingNodes = GetSurroundingContexts(nodePosition);
        }
    }

    // Analyse and add surrounding data to node context
    private List<NodeContext> GetSurroundingContexts(Vector2 position)
    {
        var top = GetContextFromPosition(new Vector2(position.x, position.y - 1));
        var right = GetContextFromPosition(new Vector2(position.x - 1, position.y));
        var bottom = GetContextFromPosition(new Vector2(position.x, position.y + 1));
        var left = GetContextFromPosition(new Vector2(position.x + 1, position.y));
        return new List<NodeContext>{top, right, bottom, left};
    }

    // It returns null if can't find node from position
    private NodeContext GetContextFromPosition(Vector2 position)
    {
        return _grid.FirstOrDefault(context => context.position == position);
    }

    // Gets the parent object of the stack, and check if the movement is available for its position.
    private void OnSwipe(Direction swipeDirection, GameObject selectedNode)
    {
        var selectedContext = selectedNode.GetComponent<NodeContext>();
        var selectedStack = selectedContext.GetParent;
        
        if (_gameIsOver || _blockInputsWhileTween || !selectedStack.Interactable || !selectedNode.CompareTag("Ingredients"))
        {
            selectedStack.transform.DOShakeRotation(0.3f, GetVectorFromDirection(swipeDirection) * 20f, 10, 2f).SetEase(Ease.InOutBack);
            return;
        }

        var validDirections = GetValidSurroundings(selectedStack);
        if (validDirections.Contains(swipeDirection))
            MoveToDesiredNode(selectedStack, selectedStack.surroundingNodes[(int) swipeDirection], swipeDirection);
        else
            selectedStack.transform.DOShakeRotation(0.3f, GetVectorFromDirection(swipeDirection) * 20f, 10, 2f).SetEase(Ease.InOutBack);
    }

    private List<Direction> GetValidSurroundings(NodeContext node)
    {
        var availableDirections = new List<Direction>();
        foreach (var surrounding in node.surroundingNodes)
        {
            if (surrounding != null && surrounding.Interactable)
                availableDirections.Add((Direction) node.surroundingNodes.IndexOf(surrounding));
        }

        return availableDirections;
    }

    // Translates direction to a Vector3, for movement and rotation purposes.
    private Vector3 GetVectorFromDirection(Direction direction)
    {
        switch (direction)
        {
            case Direction.Top:
                return Vector3.left;
            case Direction.Right:
                return Vector3.forward;
            case Direction.Bottom:
                return Vector3.right;
            case Direction.Left:
                return Vector3.back;
            default:
                return Vector3.zero;
        }
    }

    private void MoveToDesiredNode(NodeContext selectedNode, NodeContext targetNode, Direction direction)
    {
        onSwipeSuccessful?.Invoke();
        
        _blockInputsWhileTween = true;
        var targetNodeHeight = GetNodeHeight(targetNode.ChildrenCount);
        var selectedNodeHeight = GetNodeHeight(selectedNode.ChildrenCount);

        // Tween rotation - rotates object to put on target node
        selectedNode.Interactable = false;
        selectedNode.parentNode = targetNode;
        targetNode.childrenNodes.Add(selectedNode);

        var rotate = GetVectorFromDirection(direction) * 180;
        selectedNode.assignedNodeObject.transform.DORotate(
            selectedNode.assignedNodeObject.transform.rotation.eulerAngles + rotate,
            0.25f).SetEase(Ease.OutSine);
        
        // Tween movement with bezier path, from actual, to midpoint, to targetPosition, when tween is completed, enable new movement from swipe
        var targetPosition = new Vector3(
            targetNode.position.x,
            targetNodeHeight + selectedNodeHeight, 
            targetNode.position.y);

        var actualPosition = selectedNode.assignedNodeObject.transform.position;
        var midPosition = new Vector3(actualPosition.x + (targetPosition.x - actualPosition.x) / 2, targetNodeHeight + selectedNodeHeight + 1f,
            actualPosition.z + (targetPosition.z - actualPosition.z) / 2);

        selectedNode.assignedNodeObject.transform.DOPath(new[] {midPosition, targetPosition}, 0.25f, PathType.CatmullRom).SetEase(Ease.OutSine).
            OnComplete(() =>
            {
                _blockInputsWhileTween = false;
            });
        
        _grid.Find(n => n == selectedNode).position = targetNode.position;
        
        selectedNode.assignedNodeObject.transform.SetParent(targetNode.assignedNodeObject.transform);
        _lastSelectedNode = selectedNode;
        LevelManager.Instance.DecreaseNodesAvailable();

        ValidateNodes();

    }

    private void ValidateNodes()
    {
        var activeNodes = _grid.Where(n => n.Interactable).ToList();
        if (activeNodes.Count <= 1) return;
        
        foreach (var node in activeNodes)
        {
            if (GetValidSurroundings(node).Count >= 1)
            {
                return;
            }
        }
        
        OnLose?.Invoke();
    }

    private float GetNodeHeight(int childrenCount)
    {
        var height = NODE_HEIGHT;
        height += childrenCount * NODE_HEIGHT;

        return height;
    }

    // Win analysis when we got just one stack
    // if last available interactable node is a bread, and the last moved stack belonged to a bread, we got a win situation;
    private void CheckSandwichStack()
    {
        _gameIsOver = true;
        
        var winCondition = true;
        var count = 0;
        foreach (var node in _grid)
        {
            if (node.content == NodeContent.Empty || !node.Interactable) continue;
            if (node.content != NodeContent.Bread)
                winCondition = false;
            else
                count++;
        }

        if (count != 1)
        {
            winCondition = false;
        }
        
        if (_lastSelectedNode.content != NodeContent.Bread)
            winCondition = false;
        
        StartCoroutine(WaitTweenOnEnd());

        if (winCondition)
        {
            OnWin?.Invoke();
        }
        else
        {
            OnLose?.Invoke();   
        }
    }

    IEnumerator WaitTweenOnEnd()
    {
        yield return new WaitForSeconds(0.5f);
        cameraMovement.CameraLookToObject(_lastSelectedNode.GetParent.assignedNodeObject);
    }

    public void ClearAndInstantiateGrid()
    {
        if (_grid != null && _grid.Count > 0)
            ClearGrid();
        InstantiateGrid();
    }

    private void ClearGrid()
    {
        foreach (var node in _grid)
        {
            Destroy(node.gameObject);
        }
        _grid.Clear();
        
        _lastSelectedNode = null;
        _gameIsOver = false;
        _blockInputsWhileTween = false;
        
    }
}
