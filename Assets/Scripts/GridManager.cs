using System.Collections.Generic;
using System.Linq;
using InputManagement;
using Levels;
using Nodes;
using UnityEngine;

public class GridManager : MonoBehaviour
{
    private const float NodeSizeX = 1f;
    private const float NodeSizeY = 1f;
    
    private int rows;
    private int columns;

    private List<NodeContext> _grid;

    private void Start()
    {
        InputManager.OnSwipeDetected += OnSwipe;
        LevelManager.Instance.OnSandwichDone += CheckSandwichStack;
    }


    public void InstantiateGrid()
    {
        rows = GameManager.GRID_SIZE_X;
        columns = GameManager.GRID_SIZE_Y;

        _grid = new List<NodeContext>();

        var levelData = LevelManager.Instance.GetCurrentLevelData();

        if (!levelData.autoGenerated) 
        {
            for (var x = 0; x < rows; x++)
            {
                for (var y = 0; y < columns; y++)
                {
                    var nodePosition = new Vector2(x, y);
                    var nodeContent = GetNodeContent(levelData, nodePosition);
                    InstantiateNode(nodeContent, nodePosition);
                }
            }
            
            AssignSurroundingsToContext();
        }
        else
        {
            //TODO: Implement algorithm to generate levels
            Debug.LogWarning("Implement algorithm");
        }
    }

    private NodeContent GetNodeContent(Level actualLevel, Vector2 position)
    {
        return actualLevel.nodes.Exists(node => node.position == position) 
            ? actualLevel.nodes.FirstOrDefault(n => n.position == position).content
            : NodeContent.Empty;
    }

    private void InstantiateNode(NodeContent content, Vector2 position)
    {
        var nodeIngredient = ObjectHandler.Instance.GetObjectFromContent(content);
        var node = Instantiate(nodeIngredient, CalculateNodePosition(position), Quaternion.identity, transform);

        var context = node.GetComponent<NodeContext>();
        context.content = content;
        context.assignedNodeObject = node;
        context.position = position;

        context.Interactable = content != NodeContent.Empty;
        
        _grid.Add(context);
    }

    private Vector3 CalculateNodePosition(Vector2 gridPosition)
    {
        return new Vector3(NodeSizeX * gridPosition.x, 0, NodeSizeY * gridPosition.y);
    }

    private void AssignSurroundingsToContext()
    {
        foreach (var nodeContext in _grid)
        {
            var nodePosition = nodeContext.position;
            nodeContext.surroundingNodes = GetSurroundingContexts(nodePosition);
        }
    }

    // Analyse and add surrounding data to node context
    private List<NodeContext> GetSurroundingContexts(Vector2 position)
    {
        var top = GetContextFromPosition(new Vector2(position.x, position.y - 1));
        var right = GetContextFromPosition(new Vector2(position.x - 1, position.y));
        var bottom = GetContextFromPosition(new Vector2(position.x, position.y + 1));
        var left = GetContextFromPosition(new Vector2(position.x + 1, position.y));
        return new List<NodeContext>{top, right, bottom, left};
    }

    // It returns null if can't find node from position
    private NodeContext GetContextFromPosition(Vector2 position)
    {
        return _grid.FirstOrDefault(context => context.position == position);
    }

    private void OnSwipe(Direction swipeDirection, GameObject selectedNode)
    {
        var selectedContext = selectedNode.GetComponent<NodeContext>();
        var selectedStack = selectedContext.GetParent;
        if (!selectedContext.Interactable) return;
        
        switch (swipeDirection)
        {
            case Direction.Top:
                if (selectedStack.surroundingNodes[0] != null)
                {
                    MoveToDesiredNode(selectedStack, selectedStack.surroundingNodes[0], swipeDirection);
                }
                break;
            case Direction.Right:
                if (selectedStack.surroundingNodes[1] != null)
                {
                    MoveToDesiredNode(selectedStack, selectedStack.surroundingNodes[1], swipeDirection);
                }         
                break;
            case Direction.Bottom:
                if (selectedStack.surroundingNodes[2] != null)
                {
                    MoveToDesiredNode(selectedStack, selectedStack.surroundingNodes[2], swipeDirection);
                }               
                break;
            case Direction.Left:
                if (selectedStack.surroundingNodes[3] != null)
                {
                    MoveToDesiredNode(selectedStack, selectedStack.surroundingNodes[3], swipeDirection);
                }                
                break;
        }
    }

    private void MoveToDesiredNode(NodeContext selectedNode, NodeContext targetNode, Direction direction)
    {
        if (targetNode.content == NodeContent.Empty) return;
        
        var targetNodeHeight = GetNodeHeight(targetNode.ChildrenCount);
        var selectedNodeHeight = GetNodeHeight(targetNode.ChildrenCount);

        // setup objects hierarchy for rotation movement 
        selectedNode.Interactable = false;
        selectedNode.parentNode = targetNode;
        targetNode.childrenNodes.Add(selectedNode);

        
        // TODO: ADD TWEEN MOVEMENTS ON NODE
        selectedNode.assignedNodeObject.transform.position = new Vector3(
            targetNode.position.x,
            targetNodeHeight + selectedNodeHeight, 
            targetNode.position.y);

        _grid.Find(n => n == selectedNode).position = targetNode.position;
        
        selectedNode.assignedNodeObject.transform.SetParent(targetNode.assignedNodeObject.transform);
        selectedNode.Interactable = true;
        LevelManager.Instance.DecreaseNodesAvailable();

    }

    private float GetNodeHeight(int childrenCount)
    {
        var height = GameManager.NODE_HEIGHT/2f;
        height += childrenCount * GameManager.NODE_HEIGHT;
        
        return height;
    }

    private void CheckSandwichStack()
    {
        //TODO: WIN LOGIC
        Debug.Log("Sandwich done");
    }
}
