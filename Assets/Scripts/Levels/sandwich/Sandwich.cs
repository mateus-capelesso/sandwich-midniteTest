using System.Collections.Generic;
using System.Linq;
using Ingredients;
using InputManagement;
using Loaders;
using Nodes;
using UnityEngine;

namespace Levels.sandwich
{
    public class Sandwich : GridManager
    {

        public SandwichLevelGenerator generator;
        public ObjectLoader ingredientsLoader;

        // private List<NodeContext> _grid;

        protected override void Start()
        {
            base.Start();
            SandwichLevelManager.Instance.OnSandwichDone += CheckSandwichStack;
        }
    
        public override void InstantiateGrid()
        {
            var rows = GridSizeX;
            var columns = GridSizeY;

            Grid = new List<NodeContext>();

            var levelData = SandwichLevelManager.Instance.GetCurrentLevelData();

            if (levelData.autoGenerated) 
            {
                levelData = generator.GenerateLevel(levelData);
            }

            for (var x = 0; x < rows; x++)
            {
                for (var y = 0; y < columns; y++)
                {
                    var nodePosition = new Vector2(x, y);
                    var nodeContent = GetNodeContent(levelData, nodePosition);
                    InstantiateNode((int)nodeContent, nodePosition);
                }
            }
            
            AssignSurroundingsToContext();
        }

        private IngredientType GetNodeContent(SandwichLevel actualSandwichLevel, Vector2 position)
        {
            return actualSandwichLevel.nodes.Exists(node => node.position == position) 
                ? actualSandwichLevel.nodes.FirstOrDefault(n => n.position == position).content
                : IngredientType.Empty;
        }

        private GameObject InstantiateNode(int content, Vector2 position)
        {
            var nodeIngredient = ingredientsLoader.GetObjectFromContent(content);
            var node = Instantiate(nodeIngredient, CalculateNodePosition(position), Quaternion.identity, transform);

            var context = node.GetComponent<NodeContext>();
            context.content = content;
            context.assignedNodeObject = node;
            context.position = position;

            context.Interactable = content != 0;
        
            Grid.Add(context);

            return nodeIngredient;
        }

        protected override void MoveStack(NodeContext selectedNode, NodeContext targetNode, Direction direction)
        {
            var totalHeight = GetNodeHeight(targetNode.ChildrenCount) +
                              GetNodeHeight(selectedNode.ChildrenCount);
            
            base.MoveStack(selectedNode, targetNode, direction);
            
            TweenRotateStackIntoAnother(selectedNode, direction);
            TweenMoveStackIntoAnother(selectedNode.assignedNodeObject.transform, targetNode.position, totalHeight, () =>
            {
                BlockInputsWhileTween = false;
            });

            Grid.Find(n => n == selectedNode).position = targetNode.position;
            SandwichLevelManager.Instance.DecreaseNodesAvailable();
            ValidateNodes();

        }

        private void ValidateNodes()
        {
            var activeNodes = Grid.Where(n => n.Interactable).ToList();
            if (activeNodes.Count <= 1) return;
        
            foreach (var node in activeNodes)
            {
                if (GetValidSurroundings(node).Count >= 1)
                {
                    return;
                }
            }
        
            SandwichLevelManager.Instance.LevelEnded();
        }

        // Win analysis when we got just one stack
        // if last available interactable node is a bread, and the last moved stack belonged to a bread, we got a win situation;
        private void CheckSandwichStack()
        {
            GameIsOver = true;
        
            var winCondition = true;
            var count = 0;
            foreach (var node in Grid)
            {
                if ((IngredientType)node.content == IngredientType.Empty || !node.Interactable) continue;
                if ((IngredientType)node.content != IngredientType.Bread)
                    winCondition = false;
                else
                    count++;
            }

            if (count != 1)
            {
                winCondition = false;
            }
        
            if ((IngredientType)LastSelectedNodeContext.content != IngredientType.Bread)
                winCondition = false;
        
            cameraMovement.CameraLookToObject(LastSelectedNodeContext.GetParent.assignedNodeObject);

            SandwichLevelManager.Instance.LevelEnded(winCondition);
        }
    }
}
