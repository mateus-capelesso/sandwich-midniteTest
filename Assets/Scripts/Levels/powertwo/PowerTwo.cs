using System.Collections.Generic;
using System.Linq;
using Ingredients;
using InputManagement;
using Loaders;
using Nodes;
using PowerTwo;
using UnityEngine;


namespace Levels.powertwo
{
    public class PowerTwo : GridManager
    {

        public PowerTwoLevelGenerator generator;
        public ObjectLoader nodesLoader;

        protected override void Start()
        {
            base.Start();
            PowerTwoLevelManager.Instance.OnSandwichDone += CheckSandwichStack;
        }
    
        public override void InstantiateGrid()
        {
            Grid = new List<NodeContext>();

            var levelData = PowerTwoLevelManager.Instance.GetCurrentLevelData();

            if (levelData.autoGenerated) 
            {
                levelData = generator.GenerateLevel(levelData);
            }

            for (var x = 0; x < GridSizeX; x++)
            {
                for (var y = 0; y < GridSizeY; y++)
                {
                    var nodePosition = new Vector2(x, y);
                    var nodeContent = GetNodeContent(levelData, nodePosition);
                    InstantiateNode((int)nodeContent, nodePosition);
                }
            }
            
            AssignSurroundingsToContext();
        }

        private PowerTwoNodeType GetNodeContent(PowerTwoLevel actualPowerTwoLevel, Vector2 position)
        {
            return actualPowerTwoLevel.nodes.Exists(node => node.position == position) 
                ? actualPowerTwoLevel.nodes.FirstOrDefault(n => n.position == position).nodeType
                : PowerTwoNodeType.Empty;
        }

        private GameObject InstantiateNode(int content, Vector2 position)
        {
            var nodeType = nodesLoader.GetObjectFromContent(content);
            var node = Instantiate(nodeType, CalculateNodePosition(position), Quaternion.identity, transform);
        
            var context = node.GetComponent<NodeContext>();
            context.content = content;
            context.assignedNodeObject = node;
            context.position = position;
        
            context.Interactable = content != 0;
        
            Grid.Add(context);

            return node;
        }

        
        // I was trying to work with raycast to detect whats under and above the node. It turns that it didnt work that well.
        // The same nodes are joining into only one, although it isn't moving children and parents nodes.
        private void CheckReplaceNode(NodeContext targetContext, int newNodeType, float height)
        {
            var rayPosition = new Vector3(targetContext.assignedNodeObject.transform.position.x,
                height,
                targetContext.assignedNodeObject.transform.position.z);

            Ray ray = new Ray(rayPosition, Vector3.up);
            // Debug.DrawRay(rayPosition, Vector3.up, Color.green, 10f);
            Physics.Raycast(ray, out var hit, 10f);

            if (hit.collider == null) return;
            var movedNode = hit.collider.gameObject.GetComponent<NodeContext>();

            // Debug.Log($"Raycast hit from {(PowerTwoNodeType)movedNode.content} to {(PowerTwoNodeType)targetContext.content}");
            
            if (movedNode.content != targetContext.content) return;
                
            var mesh = targetContext.assignedNodeObject.GetComponent<MeshFilter>();
            mesh.sharedMesh = nodesLoader.GetObjectFromContent(newNodeType).GetComponent<MeshFilter>().sharedMesh;
            targetContext.content = newNodeType;
            
            
            if (targetContext.childrenNodes.Contains(movedNode))
                targetContext.childrenNodes.Remove(movedNode);
            
            
            Destroy(Grid.FirstOrDefault(node => node == movedNode).gameObject);
            Grid.Remove(movedNode);

        }

        protected override void MoveStack(NodeContext selectedNode, NodeContext targetNode, Direction direction)
        {
            var totalHeight = GetNodeHeight(targetNode.ChildrenCount) + GetNodeHeight(selectedNode.ChildrenCount);
            var targetHeight = GetNodeHeight(targetNode.ChildrenCount);
            var raycastSender = targetNode.gameObject.transform.childCount > 0
                ? targetNode.gameObject.transform.GetChild(0).GetComponent<NodeContext>()
                : targetNode;

            base.MoveStack(selectedNode, targetNode, direction);
            
            TweenRotateStackIntoAnother(selectedNode, direction);
            TweenMoveStackIntoAnother(selectedNode.assignedNodeObject.transform, targetNode.position, totalHeight, () =>
            {
                // Turn two nodes into one when are the same number

                CheckReplaceNode(raycastSender, targetNode.content + 1, targetHeight);
                BlockInputsWhileTween = false;
                    
            });
            
            Grid.Find(n => n == selectedNode).position = targetNode.position;
            
            PowerTwoLevelManager.Instance.DecreaseNodesAvailable();

            ValidateNodes();

        }

        private void ValidateNodes()
        {
            var activeNodes = Grid.Where(n => n.Interactable).ToList();
            if (activeNodes.Count <= 1) return;
        
            foreach (var node in activeNodes)
            {
                if (GetValidSurroundings(node).Count >= 1)
                {
                    return;
                }
            }
        
            PowerTwoLevelManager.Instance.LevelEnded();
        }
        
        // Win analysis when we got just one stack
        // if last available interactable node is a bread, and the last moved stack belonged to a bread, we got a win situation;
        private void CheckSandwichStack()
        {
            GameIsOver = true;
        
            var winCondition = true;
            var count = 0;
            foreach (var node in Grid)
            {
                if ((IngredientType)node.content == IngredientType.Empty || !node.Interactable) continue;
                if ((IngredientType)node.content != IngredientType.Bread)
                    winCondition = false;
                else
                    count++;
            }

            if (count != 1)
            {
                winCondition = false;
            }
        
            if ((IngredientType)LastSelectedNodeContext.content != IngredientType.Bread)
                winCondition = false;
        
            cameraMovement.CameraLookToObject(LastSelectedNodeContext.GetParent.assignedNodeObject);

            PowerTwoLevelManager.Instance.LevelEnded(winCondition);
        }
    }
}